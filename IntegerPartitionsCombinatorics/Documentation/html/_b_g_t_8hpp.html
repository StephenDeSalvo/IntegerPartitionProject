<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>IntegerPartitionProject - Combinatorics Branch: BGT.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IntegerPartitionProject - Combinatorics Branch
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BGT.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements the basic geometric transformations of [2].  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;utility&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &quot;<a class="el" href="_utility_8hpp_source.html">Utility.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_unique_point_8hpp_source.html">UniquePoint.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_u_p_vector_8hpp_source.html">UPVector.hpp</a>&quot;</code><br />
</div>
<p><a href="_b_g_t_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2df82425c79cf05a0eb1c747e6b6dd7b"><td class="memTemplParams" colspan="2">template&lt;typename Z &gt; </td></tr>
<tr class="memitem:a2df82425c79cf05a0eb1c747e6b6dd7b"><td class="memTemplItemLeft" align="right" valign="top">UPVector&lt; Z &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_b_g_t_8hpp.html#a2df82425c79cf05a0eb1c747e6b6dd7b">IPC::BGT::shift</a> (UPVector&lt; Z &gt; upv, const Matrix2x2&lt; Z &gt; &amp;shear)</td></tr>
<tr class="memdesc:a2df82425c79cf05a0eb1c747e6b6dd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the shift transformation of [2] to a set of integer points.  <a href="_b_g_t_8hpp.html#a2df82425c79cf05a0eb1c747e6b6dd7b">More...</a><br /></td></tr>
<tr class="separator:a2df82425c79cf05a0eb1c747e6b6dd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fba9cb804f61eca800717542e241946"><td class="memTemplParams" colspan="2">template&lt;typename Z &gt; </td></tr>
<tr class="memitem:a3fba9cb804f61eca800717542e241946"><td class="memTemplItemLeft" align="right" valign="top">UPVector&lt; Z &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_b_g_t_8hpp.html#a3fba9cb804f61eca800717542e241946">IPC::BGT::move</a> (UPVector&lt; Z &gt; upv, const Z &amp;a, const Z &amp;b)</td></tr>
<tr class="memdesc:a3fba9cb804f61eca800717542e241946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the move transformation of [2] to a set of integer points.  <a href="_b_g_t_8hpp.html#a3fba9cb804f61eca800717542e241946">More...</a><br /></td></tr>
<tr class="separator:a3fba9cb804f61eca800717542e241946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a1d6c1dd799402c7b318ada1503fe6"><td class="memTemplParams" colspan="2">template&lt;typename Z &gt; </td></tr>
<tr class="memitem:a47a1d6c1dd799402c7b318ada1503fe6"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; UPVector&lt; Z &gt;, UPVector&lt; Z &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_b_g_t_8hpp.html#a47a1d6c1dd799402c7b318ada1503fe6">IPC::BGT::cut</a> (UPVector&lt; Z &gt; upv, const Z &amp;a, const Z &amp;b, const Z &amp;c)</td></tr>
<tr class="memdesc:a47a1d6c1dd799402c7b318ada1503fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the cut transformation of [2] to a set of integer points.  <a href="_b_g_t_8hpp.html#a47a1d6c1dd799402c7b318ada1503fe6">More...</a><br /></td></tr>
<tr class="separator:a47a1d6c1dd799402c7b318ada1503fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44824b9bf2b118f463884c611af0da78"><td class="memTemplParams" colspan="2">template&lt;typename Z &gt; </td></tr>
<tr class="memitem:a44824b9bf2b118f463884c611af0da78"><td class="memTemplItemLeft" align="right" valign="top">UPVector&lt; Z &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_b_g_t_8hpp.html#a44824b9bf2b118f463884c611af0da78">IPC::BGT::paste</a> (UPVector&lt; Z &gt; upvFirst, const UPVector&lt; Z &gt; upvSecond, bool validate=false)</td></tr>
<tr class="memdesc:a44824b9bf2b118f463884c611af0da78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the paste transformation of [2] to two sets of integer points.  <a href="_b_g_t_8hpp.html#a44824b9bf2b118f463884c611af0da78">More...</a><br /></td></tr>
<tr class="separator:a44824b9bf2b118f463884c611af0da78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de1281000dd15db3df4772c4ef40e1"><td class="memTemplParams" colspan="2">template&lt;typename Z &gt; </td></tr>
<tr class="memitem:ab0de1281000dd15db3df4772c4ef40e1"><td class="memTemplItemLeft" align="right" valign="top">UPVector&lt; Z &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_b_g_t_8hpp.html#ab0de1281000dd15db3df4772c4ef40e1">IPC::BGT::paste</a> (const std::pair&lt; UPVector&lt; Z &gt;, UPVector&lt; Z &gt;&gt; &amp;upvPair, bool validate=false)</td></tr>
<tr class="memdesc:ab0de1281000dd15db3df4772c4ef40e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the paste transformation of [2] to two sets of integer points.  <a href="_b_g_t_8hpp.html#ab0de1281000dd15db3df4772c4ef40e1">More...</a><br /></td></tr>
<tr class="separator:ab0de1281000dd15db3df4772c4ef40e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0026fdb7234ec6682f81bc0a56289287"><td class="memTemplParams" colspan="2">template&lt;typename Z &gt; </td></tr>
<tr class="memitem:a0026fdb7234ec6682f81bc0a56289287"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; UPVector&lt; Z &gt;, UPVector&lt; Z &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_b_g_t_8hpp.html#a0026fdb7234ec6682f81bc0a56289287">IPC::BGT::shred</a> (UPVector&lt; Z &gt; upv)</td></tr>
<tr class="memdesc:a0026fdb7234ec6682f81bc0a56289287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the shred transformation of [2] to a set of integer points.  <a href="_b_g_t_8hpp.html#a0026fdb7234ec6682f81bc0a56289287">More...</a><br /></td></tr>
<tr class="separator:a0026fdb7234ec6682f81bc0a56289287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5065906ef7f5441b36774233da97169"><td class="memTemplParams" colspan="2">template&lt;typename Z &gt; </td></tr>
<tr class="memitem:ae5065906ef7f5441b36774233da97169"><td class="memTemplItemLeft" align="right" valign="top">UPVector&lt; Z &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_b_g_t_8hpp.html#ae5065906ef7f5441b36774233da97169">IPC::BGT::stretch</a> (UPVector&lt; Z &gt; upv, const Z &amp;k, const Z &amp;l)</td></tr>
<tr class="memdesc:ae5065906ef7f5441b36774233da97169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the stretch transformation of [2] to a set of integer points.  <a href="_b_g_t_8hpp.html#ae5065906ef7f5441b36774233da97169">More...</a><br /></td></tr>
<tr class="separator:ae5065906ef7f5441b36774233da97169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b96e8a6ef9854bdf51fb4ab97ef46b"><td class="memTemplParams" colspan="2">template&lt;typename Z &gt; </td></tr>
<tr class="memitem:ac5b96e8a6ef9854bdf51fb4ab97ef46b"><td class="memTemplItemLeft" align="right" valign="top">UPVector&lt; Z &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_b_g_t_8hpp.html#ac5b96e8a6ef9854bdf51fb4ab97ef46b">IPC::BGT::conjugate</a> (UPVector&lt; Z &gt; upv)</td></tr>
<tr class="memdesc:ac5b96e8a6ef9854bdf51fb4ab97ef46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the conjugate transformation of [2] to a set of integer points.  <a href="_b_g_t_8hpp.html#ac5b96e8a6ef9854bdf51fb4ab97ef46b">More...</a><br /></td></tr>
<tr class="separator:ac5b96e8a6ef9854bdf51fb4ab97ef46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the basic geometric transformations of [2]. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="file_ac5b96e8a6ef9854bdf51fb4ab97ef46b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Z &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UPVector&lt;Z&gt; IPC::BGT::conjugate </td>
          <td>(</td>
          <td class="paramtype">UPVector&lt; Z &gt;&#160;</td>
          <td class="paramname"><em>upv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the conjugate transformation of [2] to a set of integer points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Z</td><td>is the integer type of the operand objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upv</td><td>is the UPVector whose points are to be reflected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the UPVector post-reflection</dd></dl>
<p>Please refer to [2] for the full detailing of the transformation that this function aims to mimic. </p>

</div>
</div>
<a class="anchor" id="file_a47a1d6c1dd799402c7b318ada1503fe6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Z &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;UPVector&lt;Z&gt;,UPVector&lt;Z&gt; &gt; IPC::BGT::cut </td>
          <td>(</td>
          <td class="paramtype">UPVector&lt; Z &gt;&#160;</td>
          <td class="paramname"><em>upv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Z &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Z &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Z &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the cut transformation of [2] to a set of integer points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Z</td><td>is the integer type of the operand objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upv</td><td>is the UPVector whose points are to be cut </td></tr>
    <tr><td class="paramname">a</td><td>is a value used to define the line along which the points are to be divided </td></tr>
    <tr><td class="paramname">b</td><td>is a value used to define the line along which the points are to be divided </td></tr>
    <tr><td class="paramname">c</td><td>is a value used to define the line along which the points are to be divided </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the UPVector post-cut as a pair of UPVectors</dd></dl>
<p>Please refer to [2] for the full detailing of the transformation that this function aims to mimic.</p>
<p>Suppose we are viewing a Ferrers diagram with the line y = c/a - b/ax drawn over it. Generally, then the first element of the returned object containes all those points in the diagram visually below or on the line, and the second element contains all those points in the diagram which are strictly above it, visually.</p>
<p>To have a return object whose first element contains all those points in the diagram visually above or on the line, figure out the equation of the line and multiply a, b, and c by -1 for the input. </p>

</div>
</div>
<a class="anchor" id="file_a3fba9cb804f61eca800717542e241946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Z &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UPVector&lt;Z&gt; IPC::BGT::move </td>
          <td>(</td>
          <td class="paramtype">UPVector&lt; Z &gt;&#160;</td>
          <td class="paramname"><em>upv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Z &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Z &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the move transformation of [2] to a set of integer points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Z</td><td>is the integer type of the operand objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upv</td><td>is the UPVector whose points are to be moved </td></tr>
    <tr><td class="paramname">a</td><td>is the amount by which to translate the x-value of the input points </td></tr>
    <tr><td class="paramname">b</td><td>is the amount by which to translate the y-value of the input points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the UPVector post-move</dd></dl>
<p>Please refer to [2] for the full detailing of the transformation that this function aims to mimic. </p>

</div>
</div>
<a class="anchor" id="file_a44824b9bf2b118f463884c611af0da78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Z &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UPVector&lt;Z&gt; IPC::BGT::paste </td>
          <td>(</td>
          <td class="paramtype">UPVector&lt; Z &gt;&#160;</td>
          <td class="paramname"><em>upvFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UPVector&lt; Z &gt;&#160;</td>
          <td class="paramname"><em>upvSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>validate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the paste transformation of [2] to two sets of integer points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Z</td><td>is the integer type of the operand objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upvFirst</td><td>is the first set of integer points </td></tr>
    <tr><td class="paramname">upvSecond</td><td>is the second set of integer points </td></tr>
    <tr><td class="paramname">validate</td><td>is used to determine if two points occupy the same position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the two input sets of integer points, post-paste</dd></dl>
<p>Please refer to [2] for the full detailing of the transformation that this function aims to mimic.</p>
<p>By setting validate to true, the function asserts that there is no point in upvFirst that occupies the same position as a point in upvSecond. </p>

</div>
</div>
<a class="anchor" id="file_ab0de1281000dd15db3df4772c4ef40e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Z &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UPVector&lt;Z&gt; IPC::BGT::paste </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; UPVector&lt; Z &gt;, UPVector&lt; Z &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>upvPair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>validate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the paste transformation of [2] to two sets of integer points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Z</td><td>is the integer type of the operand objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upvPair</td><td>is the pair of integer point sets </td></tr>
    <tr><td class="paramname">validate</td><td>determines if the first and second pair elements contain points at the same location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the two input sets of integer points, post-paste</dd></dl>
<p>Please refer to [2] for the full detailing of the transformation that this function aims to mimic.</p>
<p>By setting validate to true, the function asserts that there is no point in upvFirst that occupies the same position as a point in upvSecond. </p>

</div>
</div>
<a class="anchor" id="file_a2df82425c79cf05a0eb1c747e6b6dd7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Z &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UPVector&lt;Z&gt; IPC::BGT::shift </td>
          <td>(</td>
          <td class="paramtype">UPVector&lt; Z &gt;&#160;</td>
          <td class="paramname"><em>upv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_i_p_c_1_1_matrix2x2.html">Matrix2x2</a>&lt; Z &gt; &amp;&#160;</td>
          <td class="paramname"><em>shear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the shift transformation of [2] to a set of integer points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Z</td><td>is the integer type of the operand objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upv</td><td>is the UPVector whose points are to be shifted </td></tr>
    <tr><td class="paramname">shear</td><td>is the <a class="el" href="struct_i_p_c_1_1_matrix2x2.html" title="A 2x2 matrix of elements in the integer plane. ">Matrix2x2</a> determining the shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the UPVector post-shift</dd></dl>
<p>Please refer to [2] for the full detailing of the transformation that this function aims to mimic.</p>
<p>Before proceeding, the function asserts that the input matrix is a shear matrix. </p>

</div>
</div>
<a class="anchor" id="file_a0026fdb7234ec6682f81bc0a56289287"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Z &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;UPVector&lt;Z&gt;,UPVector&lt;Z&gt; &gt; IPC::BGT::shred </td>
          <td>(</td>
          <td class="paramtype">UPVector&lt; Z &gt;&#160;</td>
          <td class="paramname"><em>upv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the shred transformation of [2] to a set of integer points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Z</td><td>is the integer type of the operand objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upv</td><td>is the UPVector whose points are to be shredded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the UPVector post-shred as a pair of UPVectors</dd></dl>
<p>Please refer to [2] for the full detailing of the transformation that this function aims to mimic.</p>
<p>The first element of the returned object contains all those points whose x-coordinate is even, and the second contains all those whose x-coordinate is odd. </p>

</div>
</div>
<a class="anchor" id="file_ae5065906ef7f5441b36774233da97169"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Z &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UPVector&lt;Z&gt; IPC::BGT::stretch </td>
          <td>(</td>
          <td class="paramtype">UPVector&lt; Z &gt;&#160;</td>
          <td class="paramname"><em>upv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Z &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Z &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the stretch transformation of [2] to a set of integer points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Z</td><td>is the integer type of the operand objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upv</td><td>is the UPVector whose points are to be stretched </td></tr>
    <tr><td class="paramname">k</td><td>is the factor by which to stretch the points along the y-axis </td></tr>
    <tr><td class="paramname">l</td><td>is the factor by which to compress the points along the x-axis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the UPVector post-stretch</dd></dl>
<p>Please refer to [2] for the full detailing of the transformation that this function aims to mimic. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
